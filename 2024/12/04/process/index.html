<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="myslqyr">





<title>4.process | myslqyr&#39;s blog</title>



    <link rel="icon" href="/favicon1.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 7.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">myslqyr&#39;s blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">myslqyr&#39;s blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">4.process</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">myslqyr</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">December 4, 2024&nbsp;&nbsp;16:29:56</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/os/">os</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="内核3-进程管理"><a href="#内核3-进程管理" class="headerlink" title="内核3 进程管理"></a>内核3 进程管理</h1><p>本篇我们主要来讨论一下进程的调度、同步、互斥。关于进程的创建以后再论。我们先来看最简单的情况：人为在内核中添加两个进程（first task和init task），并对这两个进程进行调度。通过这个例子可以让我们对进程的调度、同步以及互斥有一个直观的认识。</p>
<h3 id="TSS段简介"><a href="#TSS段简介" class="headerlink" title="TSS段简介"></a>TSS段简介</h3><p>TSS段（任务状态段）是intel cpu中用来描述一个任务的状态的数据结构。<del>关于PCB和TSS的区别我暂时没找到什么相关的资料，应该可以当成一样的来理解。</del><br><img src="/2024/12/04/process/1.jpg" alt="tss1"><br><img src="/2024/12/04/process/2.jpg" alt="tss2"><br>通过TSS段结构以及第一个图可知，TSS实际上是一块内存区域，储存了一个任务的状态信息（硬件上下文）。<br>TR寄存器中存储了当前任务TSS段的选择子，通过查找选择子在GDT表中的表项来找到TSS描述符，进而找到TSS段在内存中的位置。因此当操作系统让CPU在多个进程之间切换时，核心工作就是保存上一程序的运行状态到自己的TSS中，再加载新任务的TSS到相应位置中。<br><img src="/2024/12/04/process/3.jpg" alt="tss_selector"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tss_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> pre_link;</span><br><span class="line">	<span class="type">uint32_t</span> esp0, ss0, esp1, ss1, esp2, ss2;</span><br><span class="line">	<span class="type">uint32_t</span> cr3;</span><br><span class="line">	<span class="type">uint32_t</span> eip, eflags, eax, ecx, edx, ebx, esp, ebp, esi, edi;</span><br><span class="line">	<span class="type">uint32_t</span> es, cs, ss, ds, fs, gs;</span><br><span class="line">	<span class="type">uint32_t</span> ldt;</span><br><span class="line">	<span class="type">uint32_t</span> iomap;</span><br><span class="line">&#125; <span class="type">tss_t</span>;    <span class="comment">//tss描述符结构</span></span><br></pre></td></tr></table></figure>

<p>下面我们以两个进程进行切换为例子来说明一下在进程切换的时候TSS，TSS选择子，TR寄存器发生了什么变化，CPU是怎么从第一个进程切换到第二个进程的。</p>
<p>1.初始化tss。</p>
<p>tss_init函数的作用是初始化一个任务状态段。下面说明这个函数中的一些关键的功能语句。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tss_sel = gdt_alloc_desc();  <span class="comment">//为tss分配一个空闲的GDT表项</span></span><br><span class="line">task-&gt;tss_sel = tss_sel;  <span class="comment">//将任务的选择子设置为分配好的表项</span></span><br><span class="line">segment_desc_set(tss_sel, (<span class="type">uint32_t</span>)&amp;task-&gt;tss, <span class="keyword">sizeof</span>(<span class="type">tss_t</span>),</span><br><span class="line">                     SEG_P_PRESENT | SEG_DPL0 | SEG_TYPE_TSS); <span class="comment">//设置GDT表项内容</span></span><br></pre></td></tr></table></figure>
<p>每个进程在初始化的时候都要初始化自己的TSS，这个函数会给进程分配一个GDT表项来存放任务描述符，任务描述符在进程切换的时候起到了作用。</p>
<p>2.实现任务切换</p>
<p>硬件机制的进程切换使用ljmpl指令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switch_to_tss</span><span class="params">(<span class="type">uint32_t</span> tss_selector)</span></span><br><span class="line">&#123;</span><br><span class="line">    far_jump(tss_selector, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">far_jump</span><span class="params">(<span class="type">uint32_t</span> selector, <span class="type">uint32_t</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> addr[] = &#123;offset, selector&#125;;</span><br><span class="line">	__asm__ __volatile__(<span class="string">&quot;ljmpl *(%[a])&quot;</span> ::[a] <span class="string">&quot;r&quot;</span>(addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>向ljmpl指令中传入要切换的任务的选择子，CPU就会根据传入的参数自动跳转到需要运行的任务。</p>
<p>由此可见任务切换的本质就是保存前一任务的运行状态，恢复下一任务的运行状态。当任务切换时，会将下一任务的selector传递给ljmpl指令，ljmpl指令将传入的selector存入TR寄存器，根据selector在GDT表中查找相应表项，根据表项内容定位到下一任务的TSS所在的内存空间，并将TSS的内容传递给CPU，这样就从前一个任务切换到下一个任务了。但是这么做也有一些问题。①TSS硬件切换机制效率不高。所以现代操作系统使用了软件切换机制来进行进程切换。②每次切换进程都需要手动切换，而且目前只能进行两个进程的切换，这时候就需要定时器+进程队列来对进程进行管理了。下面会详细说明一下如何对更多的进程切换进行调度，即进程的延时，同步，互斥。</p>
<h2 id="进程的管理与延时"><a href="#进程的管理与延时" class="headerlink" title="进程的管理与延时"></a>进程的管理与延时</h2><p>进程的管理与延时是非常重要的一部分内容，它可以让我们突破只能切换两个进程的限制，也可以方便我们管理所有进程的状态，同时我们也可以为进程添加延时，让进程延时运行。</p>
<h3 id="进程的管理："><a href="#进程的管理：" class="headerlink" title="进程的管理："></a>进程的管理：</h3><p>我们使用任务管理器对进程进行管理。任务管理器的结构如下图所示：<br><img src="/2024/12/04/process/4.jpg" alt="task_manager"><br>所以任务管理器可以看作是由三个链表为主体的大结构体，实例化为一个全局变量（一个内核有一个任务管理器就足够）。结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">task_manager_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">task_t</span> *curr_task; <span class="comment">// 当前运行的任务</span></span><br><span class="line"></span><br><span class="line">	<span class="type">list_t</span> ready_list; <span class="comment">// 就绪队列</span></span><br><span class="line">	<span class="type">list_t</span> task_list;  <span class="comment">// 所有已创建任务的队列</span></span><br><span class="line">	<span class="type">list_t</span> sleep_list; <span class="comment">// 延时队列</span></span><br><span class="line"></span><br><span class="line">	<span class="type">task_t</span> first_task; <span class="comment">// 内核任务</span></span><br><span class="line">	<span class="type">task_t</span> idle_task;  <span class="comment">// 空闲任务</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> app_code_sel; <span class="comment">// 任务代码段选择子</span></span><br><span class="line">	<span class="type">int</span> app_data_sel; <span class="comment">// 应用任务的数据段选择子</span></span><br><span class="line">&#125; <span class="type">task_manager_t</span>;</span><br></pre></td></tr></table></figure>
<p>以及相应的操作函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">task_manager_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">task_first_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>初始化任务管理器就是将任务管理器结构体中的变量全部设置为初始值即可。</p>
<p>对于任务节点，我们可以将其定义为以下结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">task_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		TASK_CREATED,</span><br><span class="line">		TASK_RUNNING,</span><br><span class="line">		TASK_SLEEP,</span><br><span class="line">		TASK_READY,</span><br><span class="line">		TASK_WAITING,</span><br><span class="line">		TASK_ZOMBIE,</span><br><span class="line">	&#125; state;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> name[TASK_NAME_SIZE]; <span class="comment">// 任务名字</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> pid;				<span class="comment">// 进程的pid</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">task_t</span> *<span class="title">parent</span>;</span> <span class="comment">// 父进程</span></span><br><span class="line">	<span class="type">uint32_t</span> heap_start;	<span class="comment">// 堆的顶层地址</span></span><br><span class="line">	<span class="type">uint32_t</span> heap_end;		<span class="comment">// 堆结束地址</span></span><br><span class="line">	<span class="type">int</span> status;				<span class="comment">// 进程执行结果</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> sleep_ticks; <span class="comment">// 睡眠时间</span></span><br><span class="line">	<span class="type">int</span> time_slice;	 <span class="comment">// 时间片</span></span><br><span class="line">	<span class="type">int</span> slice_ticks; <span class="comment">// 递减时间片计数</span></span><br><span class="line"></span><br><span class="line">	<span class="type">file_t</span> *file_table[TASK_OFILE_NR]; <span class="comment">// 任务最多打开的文件数量</span></span><br><span class="line"></span><br><span class="line">	<span class="type">tss_t</span> tss;		  <span class="comment">// 任务的TSS段</span></span><br><span class="line">	<span class="type">uint16_t</span> tss_sel; <span class="comment">// tss选择子</span></span><br><span class="line"></span><br><span class="line">	<span class="type">list_node_t</span> run_node;  <span class="comment">// 运行相关结点</span></span><br><span class="line">	<span class="type">list_node_t</span> wait_node; <span class="comment">// 等待队列</span></span><br><span class="line">	<span class="type">list_node_t</span> all_node;  <span class="comment">// 所有队列结点</span></span><br><span class="line">&#125; <span class="type">task_t</span>;</span><br></pre></td></tr></table></figure>
<p>任务管理器的队列里面插入的就是任务结构体中的list_node_t类型变量。</p>
<h3 id="进程的调度"><a href="#进程的调度" class="headerlink" title="进程的调度"></a>进程的调度</h3><p><strong>我们使用基本的轮转法（RR）对进程进行调度。关于RR算法的原理，任何一本OS教材都会将其作为最基本的进程调度算法来详细解释。</strong></p>
<p>就绪队列在进程调度的过程中十分重要。根据RR，向就绪队列链表中尾插 list_node_t 类型的任务结构体成员变量 run_node 代表任务已经就绪，加入到了就绪队列中。在结构体中还是用了一个枚举来表示进程当前的状态。比如:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">task_set_ready</span><span class="params">(<span class="type">task_t</span> *task)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (task != &amp;task_manager.idle_task)</span><br><span class="line">    &#123;</span><br><span class="line">        list_insert_last(&amp;task_manager.ready_list, &amp;task-&gt;run_node);</span><br><span class="line">        task-&gt;state = TASK_READY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将一个进程设置到就绪队列中时，它的state就应该改为TASK_READY，表明进程已经就绪。</p>
<p>现在有一个问题，就是就绪队列中的进程也必须要主动调用代码来进行进程的切换，这显然不是我们想看到的，我们要做的是让进程不主动调用切换的函数，也可以自动切换到下一个进程。为了达到这个目的，我们可以分成几步来做。</p>
<h4 id="1-让进程主动放弃CPU"><a href="#1-让进程主动放弃CPU" class="headerlink" title="1.让进程主动放弃CPU"></a>1.让进程主动放弃CPU</h4><p>我们可以先让进程主动释放CPU，然后由释放CPU的函数来主动调用任务切换器，由任务切换器统一进行任务切换的工作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_yield</span><span class="params">(<span class="type">void</span>)</span>	<span class="comment">//让进程主动放弃CPU</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (list_count(&amp;task_manager.ready_list) &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">task_t</span> *curr_task = task_current();</span><br><span class="line">        task_set_block(curr_task);</span><br><span class="line">        task_set_ready(curr_task);	<span class="comment">//将当前进程移至就绪队列尾部</span></span><br><span class="line"></span><br><span class="line">        task_dispatch();	<span class="comment">//任务切换器</span></span><br><span class="line">    &#125;</span><br><span class="line">    irq_leave_protection(state);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_dispatch</span><span class="params">(<span class="type">void</span>)</span>	<span class="comment">//运行就绪队列中的下一个进程</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">task_t</span> *to = task_next_run();</span><br><span class="line">    <span class="keyword">if</span> (to != task_manager.curr_task)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">task_t</span> *from = task_manager.curr_task;</span><br><span class="line"></span><br><span class="line">        task_manager.curr_task = to;</span><br><span class="line">        task_switch_from_to(from, to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_switch_from_to</span><span class="params">(<span class="type">task_t</span> *from, <span class="type">task_t</span> *to)</span>	<span class="comment">//根据selector切换任务</span></span><br><span class="line">&#123;</span><br><span class="line">    switch_to_tss(to-&gt;tss_sel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">switch_to_tss</span><span class="params">(<span class="type">uint32_t</span> tss_selector)</span></span><br><span class="line">&#123;</span><br><span class="line">    far_jump(tss_selector, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-让进程按时间片运行"><a href="#2-让进程按时间片运行" class="headerlink" title="2.让进程按时间片运行"></a>2.让进程按时间片运行</h4><p>让进程按时间片运行，就可以让进程不显式释放CPU，通过时间片轮转进行中断，从而释放CPU资源进行进程切换的操作。首先我们要添加与时间有关的字段。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在task结构体中添加</span></span><br><span class="line">	<span class="type">int</span> sleep_ticks; <span class="comment">// 睡眠时间</span></span><br><span class="line">	<span class="type">int</span> time_slice;	 <span class="comment">// 时间片</span></span><br><span class="line"><span class="comment">//在task_init中添加</span></span><br><span class="line">    task-&gt;time_slice = TASK_TIME_SLICE_DEFAULT;</span><br><span class="line">    task-&gt;slice_ticks = task-&gt;time_slice;</span><br></pre></td></tr></table></figure>
<p>之后是在定时器中断函数中对当前进程的时间片进行递减操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_handler_timer</span><span class="params">(<span class="type">exception_frame_t</span> *frame)</span></span><br><span class="line">&#123;</span><br><span class="line">    sys_tick++;</span><br><span class="line">    pic_send_eoi(IRQ0_TIMER);</span><br><span class="line"></span><br><span class="line">    task_time_tick();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_time_tick</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">task_t</span> *curr_task = task_current();</span><br><span class="line">    <span class="keyword">if</span> (--curr_task-&gt;slice_ticks == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        curr_task-&gt;slice_ticks = curr_task-&gt;time_slice;</span><br><span class="line">        task_set_block(curr_task);</span><br><span class="line">        task_set_ready(curr_task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    task_dispatch();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次定时器产生中断时都会调用task_time_tick函数，这个函数会获取当前的进程并将其时间片减一，时间片为零之后恢复时间片并进行一次进程切换。这样我们就可以让进程运行特定的时间之后由定时器来自动进行进程的切换，无需进程主动调用切换函数。</p>
<h4 id="3-临界资源及其保护方式"><a href="#3-临界资源及其保护方式" class="headerlink" title="3.临界资源及其保护方式"></a>3.临界资源及其保护方式</h4><p>按照RR算法对进程进行调度，会在进程切换的时候出现一些问题。<br><img src="/2024/12/04/process/5.jpg" alt="problem"></p>
<p>可以看出，在first main没有打印完成时由于时间片为零，强制进行了进程切换，导致开始打印了init task的结果。这样的输出显然是错误的。关于临界资源和临界区，OS教材中有详细的解释。简单来说，临界资源是同一时刻只能被同一进程使用的资源，如全局变量、硬件资源等。临界区就是使用临界资源的代码。实现打印功能、向屏幕输出信息的串口就属于硬件临界资源，由于上述两个进程在同时访问了这个临界资源，导致输出出现了问题。</p>
<p>对临界资源的保护，OS教材上也提供了许多方法，比如关中断、利用Test-and-Set指令、利用Swap指令，信号量机制等。目前我们先采用最简单最暴力的方式：关中断。在一个进程进入临界区时禁用掉中断保证只有它自己一个进程可以访问临界资源，访问完毕后再开中断实现进程切换等中断操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">irq_state_t</span> <span class="title function_">irq_enter_protection</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">irq_state_t</span> state = read_eflags();	<span class="comment">//获取eflags寄存器的值</span></span><br><span class="line">    irq_disable_global();</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq_leave_protection</span><span class="params">(<span class="type">irq_state_t</span> state)</span></span><br><span class="line">&#123;</span><br><span class="line">    write_eflags(state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title function_">read_eflags</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> eflags;</span><br><span class="line"></span><br><span class="line">	__asm__ __volatile__(<span class="string">&quot;pushfl\n\tpopl %%eax&quot;</span> : <span class="string">&quot;=a&quot;</span>(eflags));</span><br><span class="line">	<span class="keyword">return</span> eflags;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">write_eflags</span><span class="params">(<span class="type">uint32_t</span> eflags)</span></span><br><span class="line">&#123;</span><br><span class="line">	__asm__ __volatile__(<span class="string">&quot;pushl %%eax\n\tpopfl&quot;</span> ::<span class="string">&quot;a&quot;</span>(eflags));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>state表示进入临界区前系统中断的开&#x2F;关。如果系统之前的中断是关闭的，进程访问完临界资源之后也不应该将中断开启，所以要通过state来表示中断开关的状态。中断是否开启则是在eflags寄存器的IF标志位中，所以关中断前将eflags的值保存在state中，访问结束后将eflags的值恢复即可。对串口临界资源进行保护后，我们的输出就变成正常的了。但是关中断存在许多缺点，比如降低系统效率、滥用关中断权力等。之后会采用信号量的方法来代替关中断。</p>
<h3 id="让进程延时运行"><a href="#让进程延时运行" class="headerlink" title="让进程延时运行"></a>让进程延时运行</h3><p>如果想要添加睡眠功能，让进程延时运行，就需要添加延时队列。将想要延时的队列添加在延时队列中睡眠，到达指定时间后进行唤醒并重新放回就绪队列中。之前我们已经在任务管理器中添加过延时队列和在任务结构体中添加过睡眠时间了。之后就是定义一些处理函数.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sys_msleep</span><span class="params">(<span class="type">uint32_t</span> ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (ms &lt; OS_TICK_MS)</span><br><span class="line">    &#123;</span><br><span class="line">        ms = OS_TICK_MS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从就绪队列移除，加入睡眠队列</span></span><br><span class="line">    task_set_block(task_manager.curr_task);</span><br><span class="line">    task_set_sleep(task_manager.curr_task, (ms + (OS_TICK_MS - <span class="number">1</span>)) / OS_TICK_MS);</span><br><span class="line">    task_dispatch();</span><br><span class="line">    irq_leave_protection(state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_set_sleep</span><span class="params">(<span class="type">task_t</span> *task, <span class="type">uint32_t</span> ticks)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (ticks &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    task-&gt;sleep_ticks = ticks;</span><br><span class="line">    task-&gt;state = TASK_SLEEP;</span><br><span class="line">    list_insert_last(&amp;task_manager.sleep_list, &amp;task-&gt;run_node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_set_wakeup</span><span class="params">(<span class="type">task_t</span> *task)</span></span><br><span class="line">&#123;</span><br><span class="line">    list_remove(&amp;task_manager.sleep_list, &amp;task-&gt;run_node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要让定时器来唤醒睡眠中的进程。所以完善task_time_tick函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">task_time_tick</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">task_t</span> *curr_task = task_current();</span><br><span class="line"></span><br><span class="line">    <span class="type">irq_state_t</span> state = irq_enter_protection();</span><br><span class="line">    <span class="keyword">if</span> (--curr_task-&gt;slice_ticks == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        curr_task-&gt;slice_ticks = curr_task-&gt;time_slice;</span><br><span class="line">        task_set_block(curr_task);</span><br><span class="line">        task_set_ready(curr_task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历延时队列，对时间片进行处理</span></span><br><span class="line">    <span class="type">list_node_t</span> *curr = list_first(&amp;task_manager.sleep_list);</span><br><span class="line">    <span class="keyword">while</span> (curr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">list_node_t</span> *next = list_node_next(curr);</span><br><span class="line"></span><br><span class="line">        <span class="type">task_t</span> *task = list_node_parent(curr, <span class="type">task_t</span>, run_node);</span><br><span class="line">        <span class="keyword">if</span> (--task-&gt;sleep_ticks == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            task_set_wakeup(task);</span><br><span class="line">            task_set_ready(task);</span><br><span class="line">        &#125;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    task_dispatch();</span><br><span class="line">    irq_leave_protection(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样在进程中调用sleep函数就可以让一个进程延时运行了，但是多个进程使用sleep函数还是会出现错误导致系统无法正常运行。当所有进程都在延时队列中时，就绪队列就是空的，进程切换所需要的指针就是一个无效指针，切换的时候就会导致系统崩溃。为了避免这种情况，我们要让指针一直是有效的，所以要添加一个空闲进程，当所有进程都放弃了CPU使用权时运行空闲进程，防止系统崩溃。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">task_t</span> *<span class="title function_">task_next_run</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (list_count(&amp;task_manager.ready_list) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;task_manager.idle_task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">list_node_t</span> *task_node = list_first(&amp;task_manager.ready_list);</span><br><span class="line">    <span class="keyword">return</span> list_node_parent(task_node, <span class="type">task_t</span>, run_node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当进程发生切换，运行到</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">task_t</span> *to = task_next_run();</span><br></pre></td></tr></table></figure>
<p>时，如果就绪队列中没有进程，则返回空闲进程让指针接收。同时做出这样的修改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将任务插入就绪队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_set_ready</span><span class="params">(<span class="type">task_t</span> *task)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (task != &amp;task_manager.idle_task)</span><br><span class="line">    &#123;</span><br><span class="line">        list_insert_last(&amp;task_manager.ready_list, &amp;task-&gt;run_node);</span><br><span class="line">        task-&gt;state = TASK_READY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将任务从就绪队列移除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_set_block</span><span class="params">(<span class="type">task_t</span> *task)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (task != &amp;task_manager.idle_task)</span><br><span class="line">    &#123;</span><br><span class="line">        list_remove(&amp;task_manager.ready_list, &amp;task-&gt;run_node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保证空闲进程不主动插入到就绪队列，空闲进程不会因为时间片轮转而移出就绪队列。当睡眠的进程被唤醒添加到就绪队列时，任务切换函数就可以判断当前就绪队列非空，将CPU让给下一个排队等待的进程。</p>
<h2 id="进程的同步与互斥"><a href="#进程的同步与互斥" class="headerlink" title="进程的同步与互斥"></a>进程的同步与互斥</h2><p>下面我们会实现信号量与互斥锁来完成进程的同步与互斥。同样OS教材上对信号量和互斥锁等概念有详细的解释。</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>我们用一个结构体来表示信号量，同样会有一些处理函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">sem_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> count;        <span class="comment">// 信号量计数</span></span><br><span class="line">    <span class="type">list_t</span> wait_list; <span class="comment">// 等待的进程列表</span></span><br><span class="line">&#125; <span class="type">sem_t</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 信号量初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> init_count)</span></span><br><span class="line">&#123;</span><br><span class="line">    sem-&gt;count = init_count;</span><br><span class="line">    list_init(&amp;sem-&gt;wait_list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 申请信号量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">irq_state_t</span> irq_state = irq_enter_protection();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sem-&gt;count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sem-&gt;count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">task_t</span> *curr = task_current();</span><br><span class="line">        task_set_block(curr);</span><br><span class="line">        list_insert_last(&amp;sem-&gt;wait_list, &amp;curr-&gt;wait_node);</span><br><span class="line">        task_dispatch();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    irq_leave_protection(irq_state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放信号量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_notify</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">irq_state_t</span> irq_state = irq_enter_protection();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (list_count(&amp;sem-&gt;wait_list))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">list_node_t</span> *node = list_remove_first(&amp;sem-&gt;wait_list);</span><br><span class="line">        <span class="type">task_t</span> *task = list_node_parent(node, <span class="type">task_t</span>, wait_node);</span><br><span class="line">        task_set_ready(task);</span><br><span class="line"></span><br><span class="line">        task_dispatch();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sem-&gt;count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    irq_leave_protection(irq_state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取信号量的当前值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_count</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">irq_state_t</span> irq_state = irq_enter_protection();</span><br><span class="line">    <span class="type">int</span> count = sem-&gt;count;</span><br><span class="line">    irq_leave_protection(irq_state);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等信号时，如果信号计数为零，则进程放置到信号量结构体中的等待队列，否则计数器减一，进程继续执行。发信号时如果有进程等待则唤醒进程继续执行，否则增加信号量的计数（FIFO方式取出进程）。以first task和init task为例来说明一下信号量的用法。</p>
<p>①：两个进程要确定一个信号量sem并初始化，初始信号量为0。</p>
<p>②：first task打印完信息后发一个信号。</p>
<p>③：init task接收到信号才能打印信息。</p>
<p>这样就实现了这两个进程的同步按序运行，而且不会因为访问临界资源而产生冲突。</p>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>信号量也可以实现互斥功能，但是使用互斥锁是更好的方法。（但是互斥锁也是信号量的一种，与二元信号量类似）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">mutex_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">task_t</span> *owner;</span><br><span class="line">    <span class="type">int</span> locked_count;</span><br><span class="line">    <span class="type">list_t</span> wait_list;</span><br><span class="line">&#125; <span class="type">mutex_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 锁初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mutex_init</span><span class="params">(<span class="type">mutex_t</span> *mutex)</span></span><br><span class="line">&#123;</span><br><span class="line">    mutex-&gt;locked_count = <span class="number">0</span>;</span><br><span class="line">    mutex-&gt;owner = (<span class="type">task_t</span> *)<span class="number">0</span>;</span><br><span class="line">    list_init(&amp;mutex-&gt;wait_list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 申请锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mutex_lock</span><span class="params">(<span class="type">mutex_t</span> *mutex)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">irq_state_t</span> irq_state = irq_enter_protection();</span><br><span class="line"></span><br><span class="line">    <span class="type">task_t</span> *curr = task_current();</span><br><span class="line">    <span class="keyword">if</span> (mutex-&gt;locked_count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        mutex-&gt;locked_count = <span class="number">1</span>;</span><br><span class="line">        mutex-&gt;owner = curr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mutex-&gt;owner == curr)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        mutex-&gt;locked_count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">task_t</span> *curr = task_current();</span><br><span class="line">        task_set_block(curr);</span><br><span class="line">        list_insert_last(&amp;mutex-&gt;wait_list, &amp;curr-&gt;wait_node);</span><br><span class="line">        task_dispatch();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    irq_leave_protection(irq_state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mutex_unlock</span><span class="params">(<span class="type">mutex_t</span> *mutex)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">irq_state_t</span> irq_state = irq_enter_protection();</span><br><span class="line"></span><br><span class="line">    <span class="type">task_t</span> *curr = task_current();</span><br><span class="line">    <span class="keyword">if</span> (mutex-&gt;owner == curr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (--mutex-&gt;locked_count == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mutex-&gt;owner = (<span class="type">task_t</span> *)<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (list_count(&amp;mutex-&gt;wait_list))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">list_node_t</span> *task_node = list_remove_first(&amp;mutex-&gt;wait_list);</span><br><span class="line">                <span class="type">task_t</span> *task = list_node_parent(task_node, <span class="type">task_t</span>, wait_node);</span><br><span class="line">                task_set_ready(task);</span><br><span class="line">                mutex-&gt;locked_count = <span class="number">1</span>;</span><br><span class="line">                mutex-&gt;owner = task;</span><br><span class="line"></span><br><span class="line">                task_dispatch();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    irq_leave_protection(irq_state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于多个进程可能同时申请和释放互斥锁，所以要用关中断的方法来进行保护。当现在运行的进程申请互斥锁时，计数器会加一，同时将互斥锁的owner设置为当前进程。如果有重复上锁行为，只需要将计数器自增。如果申请上锁时计数器不为零，则将该进程移入等待队列并切换任务。释放时只有锁的拥有者才能将锁释放，如果等待队列中有进程的话也会将其放入就绪队列防止进程饥饿，同时将锁的权限转让给它。之后对临界资源的保护就可以使用互斥锁了。</p>
<p>到这里进程的大部分知识已经完结。后续关于进程的问题会在接下来的文章中继续讲解。</p>

        </div>

        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/os/"># os</a>
                    
                        <a href="/tags/kernel/"># kernel</a>
                    
                        <a href="/tags/process/"># process</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2024/12/10/pa1/">pa1</a>
            
            
            <a class="next" rel="next" href="/2024/12/02/pa-preview/">pa_preview</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© myslqyr | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>